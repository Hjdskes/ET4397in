Question 1:

1. Regular ARP operation: **Permitted**
    1. `arp who-has <target-IP>? tell <sender-IP>`
    2. `arp reply <target-IP> is-at <MAC>`
2. Gratuitous ARP, both reply and request: **Notice**
    1. `arp reply <sender-IP> is-at <MAC>`, or `arp who-has <sender-IP>? tell
       <sender-IP>`
3. Binding to broadcast address: **Error**
    1. `arp reply <target-IP> is-at ff:ff:ff:ff:ff:ff`
4. ARP requests that are not sent to the broadcast address: **Notice**
    1. `ar$tha` is not `ff:ff:ff:ff:ff:ff`
5. ARP replies that are not sent to the unicast address of the sender: **Notice**
    1. `ar$tha` in the reply packet is not equal to `ar$sha` in the request
       packet.
6. ARP packets that are not internally consistent in that the MAC address of the
   link layer header match those in the ARP packet: **Notice**
    1. Ethernet address of destination is not equal to `ar$tha`
    2. Ethernet address of sender is not equal to `ar$sha`.

Question 2:

The configuration format I chose is JSON, due to its trade-offs between
versatility, readability and ease of use from the programmer's perspective.

A JSON file is easily parsed into structs in Golang, but for those details I
refer you to the code. An example configuration snippet (taken from
`config.json`) is the following:

```
{
	"arp-bindings":
	{
		"192.168.0.1":
		[
			"aa:bb:cc:dd:ee:ff"
		],
		"192.168.0.2":
		[
			"aa:aa:aa:aa:aa:aa",
			"bb:bb:bb:bb:bb:bb"
		]
	}
}
```

This snippet defines the following three bindings:

1. 192.168.0.1 -> aa:bb:cc:dd:ee:ff
2. 192.168.0.2 -> aa:aa:aa:aa:aa:aa
3. 192.168.0.2 -> bb:bb:bb:bb:bb:bb

The test suite of ARP packets can be found in `functional/arp.pcap` and is
generated by the `functional.arp.py` script. In the same directory you will also
find the sample `dns.pcap` file of last week. You can run the test with the
following command: `./ET4397IN --source="functional/arp.pcap"`.

Question 3:

The only thing that is detectable by another party is ARP replies to requests
that have already been answered. To this end, the DAI remembers requests. Now
when a reply comes in, there are three possibilities:

1. The reply is gratuitous: do nothing.
2. The reply is not gratuitous and it is a reply to a message in the remembered
   list of requests: this is valid behaviour; drop the remembered request.
3. The reply is not grauitous and it is not a reply to a message in the
   remembered list of requests: this is invalid behaviour and should be logged.

The same cannot be done for requests, as a request that has already been seen
does not necessarily indicate an implementation failure. For example, it could
just be that the reply has not been received by the sender and the sender is
trying again.
